<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Analog Camera</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#111;color:#fff;font-family:monospace;overflow:hidden}

.app{width:100vw;height:100vh;display:flex;flex-direction:column}

.top-bar{display:flex;align-items:center;justify-content:space-between;padding:12px;background-image: url(estilo/top.png);background-size: 115px;}
#viewfinder{width:90px;height:90px;border:2px solid #fff;overflow:hidden; /* added position relative */ position:relative;}
#viewfinder video{width:100%;height:100%;object-fit:cover}
.counter{font-size:22px;background: rgb(16, 16, 16);border: 5px solid #A5A89D;border-radius: 9px;}
.shutter{width:80px;height:80px;border-radius:50%;border:6px solid #a86532;cursor:pointer;
background: #E88133;
background: -moz-linear-gradient(left, #7f5913 0%, #E88133 100%);
background: -webkit-linear-gradient(left, #7f5913 0%, #E88133 100%);
background: linear-gradient(to right, #7f5913 0%, #E88133 100%);
box-shadow: 4px 5px 18px -1px rgba(0,0,0,0.75);
-webkit-box-shadow: 4px 5px 18px -1px rgba(0,0,0,0.75);
-moz-box-shadow: 4px 5px 18px -1px rgba(0,0,0,0.75);
}
.black-screen{flex:1;background:#000;background-image: url(estilo/fondo.png);}

/* film select (now a horizontal carousel/slider) */
#film-select{
  position:fixed;inset:0;
  background:rgba(0,0,0,.9);
  display:none;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  z-index:10000;
}
.films-row{
  display:flex;
  flex-direction:column;
  gap:10px;
  overflow-y:auto;
  padding:12px 8px;
  max-height:72vh;
  width:100%;
  max-width:92%;
  scroll-snap-type:y mandatory;
  -webkit-overflow-scrolling:touch;
  align-items:center;
  box-sizing:border-box;
}

/* Minimal scrollbar for films list */
.films-row{
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.12) transparent;
}
/* WebKit / Safari */
.films-row::-webkit-scrollbar{ width:8px; height:8px; }
.films-row::-webkit-scrollbar-track{ background:transparent; }
.films-row::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,0.12);
  border-radius: 999px;
  border: 2px solid transparent; /* keep thumb inset for cleaner look */
  background-clip: padding-box;
  transition: background .14s ease;
}
.films-row::-webkit-scrollbar-thumb:hover,
.films-row::-webkit-scrollbar-thumb:active{ background: rgba(255,255,255,0.18); }
.films-row::-webkit-scrollbar-thumb:window-inactive{ background: rgba(255,255,255,0.08); }

/* Make thumb more visible while scrolling on Safari (overlay scrollbars) */
.films-row:hover::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.14); }
.film{display:flex;align-items:center;justify-content:center;padding:12px 14px;border:1px solid #fff;margin:6px 0;cursor:pointer;min-height:64px;flex:0 0 auto;scroll-snap-align:center;text-align:center;width:calc(min(420px, 92%));max-width:420px;position:relative;box-sizing:border-box}
.film.active{background:#fff;color:#000}
/* favorite heart */
.film .fav{position:absolute;right:8px;top:50%;transform:translateY(-50%);width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:20px;line-height:1;cursor:pointer;color:#fff;opacity:.95;user-select:none;border-radius:50%;background:transparent;touch-action:manipulation}
.film .fav:hover{background:rgba(255,255,255,0.06)}
.film .fav.active{color:#ff6b6b;background:rgba(255,107,107,0.08)}

/* Responsive tweaks for narrow devices (iPhone) to avoid accidental overflow */
@media (max-width:420px){
  .films-row{padding:10px 8px;max-height:68vh;width:100%;}
  .film{width:calc(100% - 20px);max-width:calc(100% - 20px);padding:10px 12px;margin:6px 0;min-height:60px}
  .film .fav{right:6px;width:40px;height:40px}
}

/* controls */
.controls{
  position:fixed;
  bottom:20px;
  left:12px;
  display:flex;
  gap:12px;
  z-index:5000
}
.btn{
  padding:8px 12px;
  border:1px solid #fff;
  cursor:pointer;
  background: #000;
}
.btn.active{background:#fff;color:#000}

/* develop */
#develop{
  position:fixed;
  inset:0;
  background:#000;
  display:none;
  overflow:auto;
  padding:12px;
  z-index:9999;
  flex-direction:column;
}
#develop-grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(160px,1fr));
  gap:10px;
}
#develop-grid img{
  width:100%;
  height:auto;
  aspect-ratio:auto;
  object-fit:contain;
  background:#000;
  cursor:pointer;
}
#develop-controls{
  margin-top:12px;
  display:flex;
  justify-content:center;
}
/* develop controls fixed and download button */
#develop-controls{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);z-index:20001}
.btn.primary{background:#ffd166;color:#000;border-color:#ffd166}

/* hide main UI until JS finishes init to avoid flash */
body:not(.ui-ready) .top-bar,
body:not(.ui-ready) .controls {
  opacity:0;
  pointer-events:none;
  transition:opacity .12s ease;
}

/* when the develop/gallery is visible, hide other UI elements to avoid flicker */
body.ui-ready.develop-visible .top-bar,
body.ui-ready.develop-visible .controls,
body.ui-ready.develop-visible #film-select {
  opacity:0;
  visibility:hidden;
  pointer-events:none;
  display:none !important;
}

/* flash overlay */
#flash-overlay{position:fixed;inset:0;background:#000;pointer-events:none;opacity:0;transition:opacity .18s ease;z-index:30000}
/* confirm modal */
#confirm-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.7);z-index:20000}
.confirm-box{background:#0f0f0f;color:#fff;padding:18px;border:1px solid #fff;max-width:92%;width:340px;border-radius:8px;text-align:center}
.confirm-buttons{display:flex;gap:12px;justify-content:center;margin-top:12px}
.confirm-btn{padding:8px 12px;border:1px solid #fff;cursor:pointer}
.confirm-btn.primary{background:#fff;color:#000}
/* download button green */
#downloadRoll{background:#28a745;color:#fff;}
#downloadRoll:hover{filter:brightness(.95)}
/* new vignette overlay for preview (does not affect captured photo) */
#viewfinder::after{
  content:'';
  position:absolute;
  inset:0;
  background:radial-gradient(circle at center, transparent 20%, rgba(7, 1, 24, 0.8) 80%);
  pointer-events:none;
}
</style>
</head>

<body>

<div id="film-select" style="display:none"></div>

<div class="controls" style="display:none">
  <div class="btn" id="rewind">Poner otro Rollo</div>
  <div class="btn" id="burn">FECHA / FRAME</div>
  <div class="btn" id="revealBtn">REVELAR</div>
</div>

<div class="app">
  <div class="top-bar" style="display:none">
    <div id="viewfinder"><video id="video" autoplay playsinline></video></div>
    <div class="counter"><span id="count">0</span>/24</div>
    <div class="shutter" id="shutter"></div>
  </div>
  <div class="black-screen"></div>
</div>

<div id="develop">
  <div id="develop-grid"></div>
  <div id="develop-controls">
    <div class="btn" id="downloadRoll" style="display:none">DESCARGAR ROLLO</div>
    <div class="btn" id="newRoll">CARGAR NUEVO ROLLO</div>
  </div>
</div>

<div id="flash-overlay"></div>

<!-- Confirm modal (custom styled) -->
<div id="confirm-modal">
  <div class="confirm-box">
    <div id="confirm-text">¿Confirmar acción?</div>
    <div class="confirm-buttons">
      <div class="confirm-btn" id="confirm-cancel">Cancelar</div>
      <div class="confirm-btn primary" id="confirm-ok">Confirmar</div>
    </div>
  </div>
</div>

<script>
/* ---------- STATE ---------- */
const video=document.getElementById('video');
const shutter=document.getElementById('shutter');
const filmSelect=document.getElementById('film-select');
const countEl=document.getElementById('count');
const develop=document.getElementById('develop');
const grid=document.getElementById('develop-grid');
const rewindBtn=document.getElementById('rewind');
const burnBtn=document.getElementById('burn');
const revealBtn=document.getElementById('revealBtn');
const newRollBtn=document.getElementById('newRoll');

const canvas=document.createElement('canvas');
const ctx=canvas.getContext('2d');

// capture scale - Escala de la foto (2x)
const captureScale=3;

const flashOverlay=document.getElementById('flash-overlay');
// Audio: try normal Audio first, but also prepare an AudioContext-decoded buffer as fallback
const flashSound=new Audio('flash.mp3');
flashSound.preload='auto';
let audioCtx=null;
let flashBuffer=null;
try{
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // preload and decode flash.mp3 for reliable playback via AudioContext
  fetch('flash.mp3').then(r=>r.arrayBuffer()).then(b=>audioCtx.decodeAudioData(b)).then(buf=>{ flashBuffer=buf; }).catch(()=>{ flashBuffer=null; });
}catch(e){ audioCtx=null; flashBuffer=null; }
let _currentFlashSource = null;

let LUTS=[];
let activeLUT=null;
let activeLUTFile=localStorage.getItem('activeLUTFile')||null;
// Store only IDs in localStorage; blobs are kept in IndexedDB to save memory
let photoIds=JSON.parse(localStorage.getItem('photoIds'))||[];
// track created object URLs so we can revoke them when clearing
window._objectURLs = window._objectURLs || [];
let burnInfo=localStorage.getItem('burnInfo')==='true';

countEl.textContent=photoIds.length;
burnBtn.classList.toggle('active',burnInfo);
// Favorites: store favorite LUT filenames so favorites appear first
let favoriteLUTFiles = JSON.parse(localStorage.getItem('favoriteLUTFiles')||'[]');
function saveFavorites(){ localStorage.setItem('favoriteLUTFiles', JSON.stringify(favoriteLUTFiles)); }
function isFavorite(file){ return favoriteLUTFiles.indexOf(file)!==-1; }
function toggleFavorite(file){
  const i = favoriteLUTFiles.indexOf(file);
  if(i===-1) favoriteLUTFiles.push(file); else favoriteLUTFiles.splice(i,1);
  saveFavorites();
  // reorder LUTS so favorites appear first and rebuild UI
  if(Array.isArray(LUTS) && LUTS.length) sortLUTs();
  buildFilmUI();
}
function sortLUTs(){
  const favSet = new Set(favoriteLUTFiles);
  LUTS.sort((a,b)=> ((favSet.has(b.file)?1:0) - (favSet.has(a.file)?1:0)) || a.name.localeCompare(b.name));
}

/* ---------- LUT LIST ---------- */
async function loadLUTList(){
  const res=await fetch('luts/luts.json');
  LUTS=await res.json();
  // ensure favorites are ordered first
  sortLUTs();
  buildFilmUI();
  // Restore previously selected LUT if present (so user isn't asked again)
  if(activeLUTFile){
    const lut=LUTS.find(l=>l.file===activeLUTFile);
    if(lut){
      await loadLUT(lut);
      activeLUT=lut;
      // mark UI
      document.querySelectorAll('.film').forEach(x=>{ if(x.dataset.file===activeLUTFile) x.classList.add('active'); });
      filmSelect.style.display='none';
    }
  }
}

/* ---------- LOAD LUT ---------- */
async function loadLUT(lut){
  return new Promise(res=>{
    const img=new Image();
    img.src=`luts/${lut.file}`;
    img.onload=()=>{
      const c=document.createElement('canvas');
      c.width=img.width;
      c.height=img.height;
      const cx=c.getContext('2d');
      cx.drawImage(img,0,0);
      lut.data=cx.getImageData(0,0,c.width,c.height).data;
      lut.size=Math.round(Math.cbrt(lut.data.length/4));
      res();
    };
  });
}

/* ---------- IndexedDB helper (small wrapper) ---------- */
const DB_NAME = 'analog-photos-db';
const DB_STORE = 'photos';
function openDB(){
  return new Promise((res, rej)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = ()=>{ req.result.createObjectStore(DB_STORE, {keyPath:'id'}); };
    req.onsuccess = ()=>res(req.result);
    req.onerror = ()=>rej(req.error);
  });
}
async function idbPutBlob(id, blob){
  const db = await openDB();
  return new Promise((res, rej)=>{
    const tx = db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put({id, blob});
    tx.oncomplete = ()=>res();
    tx.onerror = ()=>rej(tx.error);
  });
}
async function idbGetBlob(id){
  const db = await openDB();
  return new Promise((res, rej)=>{
    const tx = db.transaction(DB_STORE, 'readonly');
    const r = tx.objectStore(DB_STORE).get(id);
    r.onsuccess = ()=> res(r.result ? r.result.blob : null);
    r.onerror = ()=> rej(r.error);
  });
}
async function idbClearAll(){
  const db = await openDB();
  return new Promise((res, rej)=>{
    const tx = db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).clear();
    tx.oncomplete = ()=>res();
    tx.onerror = ()=>rej(tx.error);
  });
}

/* ---------- UI ---------- */
function buildFilmUI(){
  filmSelect.innerHTML='';
  const row = document.createElement('div');
  row.className = 'films-row';
  LUTS.forEach(lut=>{
    const b=document.createElement('div');
    b.className='film';
    b.textContent=lut.name;
    b.dataset.file=lut.file;
    // favorite icon
    const fav=document.createElement('div');
    fav.className='fav'+(isFavorite(lut.file)?' active':'');
    fav.title = 'Marcar como favorito';
    fav.innerHTML = isFavorite(lut.file)?'♥':'♡';
    fav.addEventListener('click', (e)=>{ e.stopPropagation(); toggleFavorite(lut.file); });
    b.appendChild(fav);

    b.onclick=async()=>{
      if(!lut.data) await loadLUT(lut);
      activeLUT=lut;
      document.querySelectorAll('.film').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      // persist selection so reloads don't ask again while roll is active
      localStorage.setItem('activeLUTFile', lut.file);
      activeLUTFile=lut.file;
      filmSelect.style.display='none';
    };

    row.appendChild(b);
  });
  filmSelect.appendChild(row);
}

/* ---------- APPLY LUT ---------- */
function applyLUT3D(){
  const img=ctx.getImageData(0,0,canvas.width,canvas.height);
  const d=img.data;
  const lut=activeLUT.data;
  const size=activeLUT.size;
  const w=Math.sqrt(lut.length/4);
  const tiles=w/size;

  for(let i=0;i<d.length;i+=4){
    const r=Math.floor(d[i]/255*(size-1));
    const g=Math.floor(d[i+1]/255*(size-1));
    const b=Math.floor(d[i+2]/255*(size-1));
    const x=r+(b%tiles)*size;
    const y=g+Math.floor(b/tiles)*size;
    const idx=(y*w+x)*4;
    d[i]=lut[idx];
    d[i+1]=lut[idx+1];
    d[i+2]=lut[idx+2];
  }
  ctx.putImageData(img,0,0);
}

/* ---------- CAMERA ---------- */
async function startCamera(){
  const constraints = { video: { facingMode: 'environment' } };
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
    try{
      const s = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = s;
      return;
    }catch(e){ console.error('navigator.mediaDevices.getUserMedia failed', e); }
  }
  const getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
  if(getUserMedia){
    try{
      getUserMedia.call(navigator, constraints, (s)=>{ video.srcObject = s; }, (err)=>{ console.error('getUserMedia callback failed', err); });
      return;
    }catch(e){ console.error('getUserMedia fallback failed', e); }
  }

  // Inform the user when camera API isn't available
  console.warn('getUserMedia is not available. Use a modern browser and HTTPS (or localhost).');
  const warn = document.createElement('div');
  warn.style.position='fixed';
  warn.style.top='12px';
  warn.style.left='50%';
  warn.style.transform='translateX(-50%)';
  warn.style.background='#ffd166';
  warn.style.color='#000';
  warn.style.padding='8px 12px';
  warn.style.zIndex=40000;
  warn.style.borderRadius='6px';
  warn.textContent='La cámara no está disponible. Usa Chrome/Firefox/Safari en HTTPS o prueba desde localhost.';
  document.body.appendChild(warn);
}

startCamera();

/* ---------- SHUTTER ---------- */
shutter.onclick=async()=>{
  if(!activeLUT||photoIds.length>=24) return;

  // play flash sound: prefer AudioContext decoded buffer (avoid double playback)
  if(audioCtx && flashBuffer){
    try{
      if(audioCtx.state==='suspended') await audioCtx.resume();
      // stop previous source if still playing
      try{ if(_currentFlashSource){ _currentFlashSource.stop(); _currentFlashSource=null; } }catch(e){}
      const src=audioCtx.createBufferSource();
      src.buffer=flashBuffer;
      src.connect(audioCtx.destination);
      src.start(0);
      _currentFlashSource = src;
      src.onended = ()=>{ if(_currentFlashSource===src) _currentFlashSource=null; };
    }catch(e){
      // fallback to regular Audio
      try{ flashSound.pause(); flashSound.currentTime=0; flashSound.play().catch(()=>{}); }catch(e){}
    }
  }else{
    try{ flashSound.pause(); flashSound.currentTime=0; flashSound.play().catch(()=>{}); }catch(e){}
  }
  if(flashOverlay) flashOverlay.style.opacity=1;
  // small delay so flash is noticeable
  await new Promise(r=>setTimeout(r,120));

  // capture at higher resolution according to captureScale
  canvas.width = Math.round(video.videoWidth * captureScale);
  canvas.height = Math.round(video.videoHeight * captureScale);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  // If burnInfo is active, draw only the date in red BEFORE applying the LUT
  if(burnInfo){
    ctx.fillStyle='rgba(255,60,60,0.95)';
    ctx.font=`${22 * captureScale}px monospace`;
    ctx.textAlign='right';
    ctx.fillText(new Date().toLocaleDateString('es-AR'),
      canvas.width-20,canvas.height-20);
  }

  // apply LUT to the whole canvas (this will affect the burned date as well)
  applyLUT3D();

  // Convert canvas to a compressed blob and store in IndexedDB to avoid large dataURLs in memory
  canvas.toBlob(async (blob)=>{
    if(!blob) return;
    const id = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
    try{
      await idbPutBlob(id, blob);
      photoIds.push(id);
      localStorage.setItem('photoIds', JSON.stringify(photoIds));
      countEl.textContent = photoIds.length;
      if(photoIds.length===24) setTimeout(()=>{ try{ reveal(); }catch(e){ console.error('reveal error',e); } },80);
    }catch(e){
      console.error('Failed to store photo blob', e);
    }
  }, 'image/jpeg', 0.77);

  // hide flash overlay soon after capture
  if(flashOverlay) setTimeout(()=>flashOverlay.style.opacity=0,120);

  
};

/* ---------- REVEAL ---------- */
// Build the develop/grid view and prepare a downloadable ZIP from a photos array
async function renderDevelopFromPhotos(arr){
  if(!arr||!arr.length) return;
  develop.style.display='flex';
  grid.innerHTML='';

  const zip=new JSZip();
  const files = [];

  const dataURLtoBlob = (dataURL)=>{
    const parts = dataURL.split(',');
    const meta = parts[0].match(/:(.*?);/)[1];
    const binary = atob(parts[1]);
    const len = binary.length;
    const u8 = new Uint8Array(len);
    for(let j=0;j<len;j++) u8[j]=binary.charCodeAt(j);
    return new Blob([u8], {type: meta});
  };

  for(let i=0;i<arr.length;i++){
    const p = arr[i];
    let blob = null;
    let url = null;

    if(typeof p === 'string' && p.startsWith('data:')){
      // legacy dataURL stored previously
      blob = dataURLtoBlob(p);
      url = URL.createObjectURL(blob);
      window._objectURLs.push(url);
    }else{
      // assume p is an ID stored in IndexedDB
      blob = await idbGetBlob(p);
      if(!blob){ console.warn('Missing blob for id', p); continue; }
      url = URL.createObjectURL(blob);
      window._objectURLs.push(url);
    }

    const img=document.createElement('img');
    img.src=url;
    img.style.cursor='pointer';
    img.title='Descargar foto';
    img.addEventListener('click', async (e)=>{
      e.preventDefault(); e.stopPropagation();
      if(window._sharingInProgress) return;
      window._sharingInProgress = true;
      const fileName = `photo_${String(i+1).padStart(2,'0')}.jpg`;
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');
      if(isMobile){
        try{
          const file = new File([blob], fileName, {type: blob.type});
          if(navigator.canShare && navigator.canShare({files:[file]})){
            try{ await navigator.share({files:[file], title: 'Foto analógica'}); }
            catch(e){ window._sharingInProgress=false; return; }
            window._sharingInProgress=false; return;
          }
        }catch(e){}
      }
      try{ const a=document.createElement('a'); a.href=url; a.download=fileName; document.body.appendChild(a); a.click(); a.remove(); }
      finally{ window._sharingInProgress=false; }
    });
    grid.appendChild(img);
    // Add blob directly to zip
    zip.file(`photo_${String(i+1).padStart(2,'0')}.jpg`, blob);
    // collect files for direct download/share
    files.push({ name: `photo_${String(i+1).padStart(2,'0')}.jpg`, blob });
  }

  const blobZip=await zip.generateAsync({type:'blob'});
  window._lastRollZip = blobZip;
  // expose files array for direct download/share
  window._lastRollFiles = files;
  const dl=document.getElementById('downloadRoll');
  if(dl){ dl.style.display='inline-block'; dl.onclick = downloadRollFiles; }
}

// Download or share all files in the last roll.
async function downloadRollFiles(){
  const files = window._lastRollFiles || [];
  if(!files.length) return;
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');

  // Try native share with multiple files on mobile if supported
  if(isMobile && navigator.canShare){
    try{
      const fileObjs = files.map(f=> new File([f.blob], f.name, {type: f.blob.type}));
      if(navigator.canShare({files: fileObjs})){
        await navigator.share({ files: fileObjs, title: 'Fotos analógicas' });
        return;
      }
    }catch(e){ /* fallthrough to download fallback */ }
  }

  // Fallback: trigger separate downloads sequentially
  for(const f of files){
    try{
      const url = URL.createObjectURL(f.blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = f.name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(e){} }, 1500);
      // small delay to avoid overwhelming the browser
      await new Promise(r=>setTimeout(r,120));
    }catch(e){}
  }
}

async function reveal(){
  try{
    if(!photoIds.length) return;
    // persist revealed photo IDs so the gallery remains across sessions
    localStorage.setItem('revealedPhotoIds', JSON.stringify(photoIds));
    // ensure develop view is visible immediately
    develop.style.display='flex';
    await renderDevelopFromPhotos(photoIds);
  }catch(err){
    console.error('reveal failed', err);
    // fallback: at least show the develop panel
    develop.style.display='flex';
  }finally{
    try{
      // clear the in-progress roll and active LUT (blobs remain in IDB for revealed gallery)
      localStorage.removeItem('photoIds');
      localStorage.removeItem('activeLUTFile');
      activeLUTFile=null; activeLUT=null; photoIds=[]; countEl.textContent=0;
    }catch(e){}
  }
}

/* ---------- CONTROLS ---------- */
revealBtn.onclick=reveal;

newRollBtn.onclick=async()=>{
  const ok=await showConfirm('Esta acción eliminará las fotos del carrete actual. ¿Deseas continuar?', 'Eliminar', 'Cancelar');
  if(!ok) return;
  develop.style.display='none';
  grid.innerHTML='';
  // clear active LUT so user re-selects
  localStorage.removeItem('activeLUTFile');
  activeLUTFile=null;
  activeLUT=null;
  document.querySelectorAll('.film').forEach(x=>x.classList.remove('active'));
  filmSelect.style.display='flex';
  // Make sure main UI is visible again (remove develop-visible state)
  try{ document.body.classList.remove('develop-visible'); }catch(e){}
  try{ document.querySelector('.top-bar').style.display=''; document.querySelector('.controls').style.display=''; }catch(e){}
  // hide download button and clear blob
  const dl=document.getElementById('downloadRoll'); if(dl) dl.style.display='none'; window._lastRollZip=null;
  // also remove any previously revealed gallery and clear stored blobs
  localStorage.removeItem('revealedPhotoIds');
  try{ await idbClearAll(); }catch(e){}
  // revoke any created object URLs
  try{ (window._objectURLs||[]).forEach(u=>{ try{ URL.revokeObjectURL(u); }catch(e){} }); window._objectURLs=[]; }catch(e){}
};

rewindBtn.onclick=async()=>{
  const ok=await showConfirm('Esta acción eliminará las fotos del carrete actual. ¿Deseas continuar?', 'Eliminar', 'Cancelar');
  if(!ok) return;
  localStorage.removeItem('photoIds');
  photoIds=[];
  countEl.textContent=0;
  develop.style.display='none';
  // also clear selected roll
  localStorage.removeItem('activeLUTFile');
  activeLUTFile=null;
  activeLUT=null;
  document.querySelectorAll('.film').forEach(x=>x.classList.remove('active'));
  filmSelect.style.display='flex';
  // restore main UI in case it was hidden by develop-visible
  try{ document.body.classList.remove('develop-visible'); }catch(e){}
  try{ document.querySelector('.top-bar').style.display=''; document.querySelector('.controls').style.display=''; }catch(e){}
  // hide download button and clear blob
  const dl=document.getElementById('downloadRoll'); if(dl) dl.style.display='none'; window._lastRollZip=null;
  // also remove any previously revealed gallery and clear stored blobs
  localStorage.removeItem('revealedPhotoIds');
  try{ await idbClearAll(); }catch(e){}
  try{ (window._objectURLs||[]).forEach(u=>{ try{ URL.revokeObjectURL(u); }catch(e){} }); window._objectURLs=[]; }catch(e){}
};

burnBtn.onclick=()=>{
  burnInfo=!burnInfo;
  localStorage.setItem('burnInfo',burnInfo);
  burnBtn.classList.toggle('active',burnInfo);
};

// Styled confirmation modal API
function showConfirm(message, okText='Confirmar', cancelText='Cancelar'){
  return new Promise(res=>{
    const modal=document.getElementById('confirm-modal');
    const txt=document.getElementById('confirm-text');
    const okBtn=document.getElementById('confirm-ok');
    const cancelBtn=document.getElementById('confirm-cancel');
    txt.textContent=message;
    okBtn.textContent=okText;
    cancelBtn.textContent=cancelText;
    modal.style.display='flex';
    const cleanup=()=>{ modal.style.display='none'; okBtn.removeEventListener('click',onOk); cancelBtn.removeEventListener('click',onCancel); };
    const onOk=()=>{ cleanup(); res(true); };
    const onCancel=()=>{ cleanup(); res(false); };
    okBtn.addEventListener('click', onOk, {once:true});
    cancelBtn.addEventListener('click', onCancel, {once:true});
  });
}

/* ---------- INIT ---------- */
(async function init(){
  await loadLUTList();
  try{
    const revealed = JSON.parse(localStorage.getItem('revealedPhotoIds')||'null');
    if(revealed && revealed.length){
      // show develop gallery and hide film selection until user loads a new roll
      await renderDevelopFromPhotos(revealed);
      filmSelect.style.display='none';
      try{ document.querySelector('.top-bar').style.display='none'; document.querySelector('.controls').style.display='none'; }catch(e){}
      document.body.classList.add('ui-ready','develop-visible');
    }else{
      // if there's no active LUT previously selected, show film selector so user can pick a roll
      if(!activeLUTFile) filmSelect.style.display='flex';
      try{ document.querySelector('.top-bar').style.display=''; document.querySelector('.controls').style.display=''; }catch(e){}
      document.body.classList.add('ui-ready');
    }
  }catch(e){
    try{ document.querySelector('.top-bar').style.display=''; document.querySelector('.controls').style.display=''; }catch(e){}
    try{ document.body.classList.add('ui-ready'); }catch(e){}
  }
})();
</script>

</body>
</html>
